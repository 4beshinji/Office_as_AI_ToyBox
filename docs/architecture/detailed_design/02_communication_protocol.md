# 02. Communication Protocol (MCP over MQTT)

## 1. Protocol Rationale
The core of SOMS is the **Model Context Protocol (MCP)**, which standardizes how AI models interact with data and tools. While MCP typically runs over HTTP (SSE) or stdio, SOMS adapts it to **MQTT** for the following reasons:
- **Asynchronicity**: Decouples the slow cognitive processes of the LLM (seconds) from the fast physical world (milliseconds).
- **Resilience**: MQTT's QoS (Quality of Service) and LWT (Last Will and Testament) ensuring reliable command delivery even on unstable Wi-Fi.
- **Lightweight**: Low overhead suitable for ESP32 microcontrollers.
- **Topology**: The Hub-and-Spoke model aligns perfectly with our Central Intelligence -> Multiple Edge Agents architecture.

## 2. Topic Taxonomy
The MQTT topic structure serves as the system's API definition.

### 2.1 Standard Topics
- **`mcp/{agent_id}/request/{method}`**: LLM sending commands to an agent.
  - `method` corresponds to MCP methods like `call_tool`, `list_tools`.
- **`mcp/{agent_id}/response/{request_id}`**: Agent responding to a specific request.
  - `request_id` is a UUID generated by the LLM (Python Bridge).
- **`office/{zone}/{device_type}/{device_id}/{channel}`**: Telemetry and state updates.
  - e.g., `office/meeting_room_a/sensor/env_01/temperature`
  -Payload: `{"value": 24.5, "unit": "c", "timestamp": 171584...}`

### 2.2 Discovery
- **`mcp/discovery`**: Agents publish their presence here on boot.
  - Payload: `{"agent_id": "esp32_01", "capabilities": ["sensor", "light_control"]}`

## 3. Payload Structure (JSON-RPC)
We encapsulate standard JSON-RPC 2.0 messages within MQTT payloads.

### Check Tool List (Request)
**Topic**: `mcp/esp32_01/request/list_tools`
```json
{
  "jsonrpc": "2.0",
  "method": "list_tools",
  "id": "req-uuid-123",
  "params": {} 
}
```

### Tool Execution (Request)
**Topic**: `mcp/esp32_01/request/call_tool`
```json
{
  "jsonrpc": "2.0",
  "method": "call_tool",
  "params": {
    "name": "set_led_color",
    "arguments": {
      "r": 255, 
      "g": 0, 
      "b": 0
    }
  },
  "id": "req-uuid-456"
}
```

### Tool Execution (Response)
**Topic**: `mcp/esp32_01/response/req-uuid-456`
```json
{
  "jsonrpc": "2.0",
  "result": {
    "content": [
      {
        "type": "text",
        "text": "LED color set to Red"
      }
    ]
  },
  "id": "req-uuid-456"
}
```

## 4. Python Bridge Architecture
The **MCP Bridge** on the central server manages the translation between the LLM's synchronous/async function calls and the asynchronous MQTT bus.

### 4.1 Core Components
1.  **MQTT Client (paho-mqtt)**: Handles connection to the broker (Mosquitto).
2.  **Pending Request Map**: A dictionary mapping `request_id` to `asyncio.Future` objects.
3.  **Tool Registry**: Dynamically builds a list of available tools from `mcp/discovery` messages.

### 4.2 Request-Response Logic
1.  **LLM Action**: The LLM generates a tool call event.
2.  **Bridge Processing**:
    - Generates a unique `request_id`.
    - Creates a `Future` and stores it in `Pending Request Map`.
    - Publishes the JSON-RPC request to `mcp/{target_id}/request/call_tool`.
3.  **Await**: The Python implementation `await future` pauses execution for that specific logic flow (non-blocking to other tasks).
4.  **Edge Processing**: The ESP32 receives the message, executes the hardware command, and publishes the result to `mcp/{target_id}/response/{request_id}`.
5.  **Bridge Resolution**:
    - The bridge subscribes to `mcp/+/response/+`.
    - Upon receiving a message, it extracts the `request_id`.
    - It looks up the `Future` in the map and calls `future.set_result(payload)`.
6.  **Completion**: The `await` finishes, and the result is returned to the LLM context.

## 5. Security Considerations
- **Authentication**: MQTT username/password for all clients.
- **Authorization**: ACLs (Access Control Lists) in Mosquitto to prevent unauthorized devices from publishing to control topics.
- **TLS**: Encryption for all MQTT traffic (optional for local-only, mandatory if exposed).
